package com.mylearn.thread.lock;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * Created by IntelliJ IDEA.
 * User: yingkh
 * Date: 12-12-25
 * Time: ????1:52
 * CopyRight:360buy
 * Descrption:  ??§Õ??????
 *
 *
 * 	1. WriteLock??????ReadLock?????????4ReadLock??????WriteLock????????????
 	2. WriteLock????????ReadLock????????????WriteLock????ReadLock????????WriteLock???????????????ReadLock????§µ?????4ReadLock??????WriteLock??????
 	3. ReadLock?????????????§Ó??????????????¦Ê¦Å?WriteLock????WriteLock?????????????????????????????????????????????§Õ?????????????????????????????????????
 	4. ??????ReadLock????WriteLock?????Interrupt,??????ReentrantLock????
 	5. WriteLock???Condition??????ReentrantLock??????????ReadLock???????Condition,???????UnsupportedOperationException????

 * To change this template use File | Settings | File Templates.
 */
public class ReentrantReadWriteLockSample {
    public static void main(String args[]) {
        testReadLock();
//        testWriteLock();
    }

    /**
     * ???????????}??????????§Õ??? ?????????get?????????????????put?§Ö????????????????5??????
     * ?????????ReadLock??????????§Ó??????WriteLock?????????
     */
    public static void testReadLock() {
        final ReadWriteLockSampleSupport support = new ReadWriteLockSampleSupport();
        support.initCache();
        Runnable runnable = new Runnable() {
            public void run() {
                support.get("test");
            }
        };

        new Thread(runnable).start();
        new Thread(runnable).start();
        new Thread(new Runnable() {
            public void run() {
                support.put("test", "test");
            }
        }).start();
    }


    /**
     * ???????????}??§Õ??????????????§ß?????????????????5s??????????????WriteLock??????
     */
    public static void testWriteLock() {

        final ReadWriteLockSampleSupport support = new ReadWriteLockSampleSupport();
        support.initCache();
        new Thread(new Runnable() {
            public void run() {
                support.put("key1", "value1");
            }
        }).start();

        new Thread(new Runnable() {
            public void run() {
                support.put("key2", "key2");
            }
        }).start();

        new Thread(new Runnable() {
            public void run() {
                support.get("key1");
            }
        }).start();

    }

}


class ReadWriteLockSampleSupport {
    private final ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();
    private final Lock readLock = reentrantReadWriteLock.readLock();
    private final Lock writeLock = reentrantReadWriteLock.writeLock();

    private volatile boolean completed;
    private Map<String, String> cache;

    public void initCache() {
        readLock.lock();
        if (!completed) {
            // ????§Õ??????????????
            readLock.unlock();
            writeLock.lock();
            if (!completed) {
                cache = new HashMap<String, String>(32);
                completed = true;
            }
            //?????§Õ???????????????
            readLock.lock();
            writeLock.unlock();
        }
        System.out.println("empty? " + cache.isEmpty());
        readLock.unlock();

    }

    public String get(String key) {
        readLock.lock();
        System.out.println(Thread.currentThread().getName() + "read.");
        startTheCountdown();
        try {
            return cache.get(key);
        } finally {
            readLock.unlock();
        }
    }

    public String put(String key, String value) {

        writeLock.lock();
        System.out.println(Thread.currentThread().getName() + "write:");
        startTheCountdown();
        try {
            return cache.put(key, value);
        } finally {
            writeLock.unlock();
        }

    }


    /**
     * ???5??
     */
    private void startTheCountdown() {
        long currentTime = System.currentTimeMillis();
        for (; ; ) {
            long diff = System.currentTimeMillis() - currentTime;
            if (diff > 5000) {
                break;
            }
        }
    }


}
